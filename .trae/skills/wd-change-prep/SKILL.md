---
name: Nnngram wd分支改动规则
description: 固化代码改动前的需求澄清、影响评估、方案设计与回滚预案。用于动手改代码前生成风险清单、验证计划与任务拆分，确保符合 wd 规范。
---

# 代码改动前准备（wd 分支）

仅针对 **Nnngram 项目** 的 **wd 分支** 生效：
- 仅当当前仓库为 `Nnngram` 且当前分支为 `wd`（或 `wd/*`）时使用本规则
- 其它分支或其它项目不适用；请使用对应分支/项目的改动规范（不要套用 `wd` 约束）

## 适用场景

- 准备开始动手改代码之前（包含重构、性能优化、兼容性修复、功能新增）
- 不确定影响范围，担心改动波及其它模块
- 需要先把验证与回滚想清楚，避免“边改边想”导致返工

## 输入信息（你需要提供/确认）

- 目标：要解决什么问题、成功标准是什么
- 现象/复现：复现步骤、日志/截图/崩溃堆栈（如有）
- 约束：兼容版本、性能要求、隐私与权限限制、上线窗口
- 代码上下文：
  - 模块/入口：涉及的模块与主要入口类
  - 关键路径：从触发点到核心逻辑的大致调用链
  - 相关文件：预计会改的文件清单（可为空，后续补）
- 测试与构建：当前能跑的构建/测试方式（Gradle 任务、设备/模拟器）
- wd 规范要点：
  - 注释：中文且 `//wd` 前缀
  - 字符串：用户可见字符串禁止硬编码，写入 `strings_nullgram.xml`（中英文）
  - 日志：使用 `import android.util.Log;`，禁止使用 `FileLog`；TAG `"wd"`，中文文案，`Log.e` 带异常堆栈，禁止敏感信息

## 输出产物（必须产出）

- 改动方案摘要：背景、目标、核心方案、备选方案（如有）
- 影响面清单：代码/数据/网络/存储/权限/UI/兼容性/性能/安全
- 验证计划：必跑命令、手工路径、边界用例、回归点
- 回滚预案：触发条件、回滚方式、数据处理（可逆/不可逆）
- 任务拆分：可拆 PR/提交的边界与依赖关系

---

## Step 1：明确问题与成功标准（先对齐“要得到什么”）

**目标**：避免做了“看起来很努力”的改动，但解决不了问题或引入新问题。

**检查点**
- 问题定义是否可验证：给出可复现步骤/输入输出/截图或堆栈
- 成功标准是否量化：例如“崩溃率为 0”“启动耗时降低 10%”“某路径不再出现 ANR”
- 需求边界是否明确：不做什么、哪些场景不支持、哪些是后续工作

**失败回滚策略**
- 若成功标准不可验证：暂停进入改动；先补充复现用例或最小可观测指标（日志/统计/性能点位）。

---

## Step 2：快速定位改动落点（先找到“该改哪里”）

**目标**：用最小时间找到入口、数据流和关键分支，不盲改。

**操作建议**
- 从 UI 入口、通知/广播入口、网络回调入口、数据库/文件 I/O 入口四类入口去找
- 沿调用链标出：输入 → 校验 → 转换 → 存储/网络 → UI 更新

**检查点**
- 是否明确“唯一可信的入口点”（或多个入口点及其条件）
- 是否识别关键数据结构/状态机（例如：会话状态、页面生命周期、缓存命中/失效）
- 是否识别异常/边界分支（空值、权限拒绝、网络失败、重复触发）

**失败回滚策略**
- 若入口不清晰：先写最小观测（受 `BuildVars.LOGS_ENABLED` 控制，TAG `"wd"`，中文描述且不含敏感信息）来确认真实路径，再继续。

---

## Step 3：影响评估（先把雷区列出来）

**目标**：提前把“可能坏在哪里”写清楚，后续验证才有抓手。

### 3.1 影响面清单（逐项判断）

**检查点**
- 代码：是否涉及公共工具类/共享组件/全局单例
- 数据：是否修改数据结构、序列化、缓存键、数据库表、偏好设置
- 网络：是否新增字段、改动请求/响应解析、改变重试逻辑
- 存储与权限：是否涉及文件路径、Uri、权限申请、Scoped Storage
- UI：是否影响布局、文案、无障碍、深色模式（如适用）
- 兼容性：不同 Android 版本行为差异（权限/存储/通知等）
- 性能：是否引入主线程 I/O、频繁分配、列表卡顿、O(n²)
- 安全与隐私：是否可能泄露敏感信息到日志/落盘/网络

**失败回滚策略**
- 若影响面过大：拆分目标，先做“最小安全修复”，把重构/优化延后到独立任务。

---

## Step 4：方案设计（主方案 + 备选方案 + 取舍理由）

**目标**：写清楚“为什么这样做”，让后续实现与评审都能对齐。

**检查点**
- 主方案：关键改动点、关键数据结构变更、关键状态转换
- 备选方案：至少一个更保守方案（用于回滚/降级）
- 取舍理由：为什么不用其它方案（复杂度/风险/兼容/性能）

**wd 规范预检查**
- 若会新增用户可见文案：预先规划字符串键名与中英文翻译位置（`strings_nullgram.xml`）
- 若会新增日志：预先定义日志点位与脱敏策略（TAG `"wd"`）
- 若会新增复杂逻辑：预留 `//wd` 注释位置解释设计意图

**失败回滚策略**
- 若主方案风险高且无备选：先把备选（降级/开关/旧逻辑回退）补齐再进入编码阶段。

---

## Step 5：验证计划（先写“怎么证明没坏”）

**目标**：编码结束后不靠“感觉”，靠可重复验证。

### 5.1 必跑命令（Windows PowerShell）

- `.\gradlew clean`
- `.\gradlew :TMessagesProj:installDebug`
- `adb shell am start -n xyz.nextalone.nnngram/org.telegram.ui.LaunchActivity`

### 5.2 手工验证路径（最少 3 条）

**检查点**
- 真机安装运行：安装 Debug 包后在真机打开 App，走到本次改动相关路径并观察行为与日志；
- 正常路径：用户常用主路径
- 边界路径：空值/无网络/权限拒绝/重复触发
- 回归路径：与改动相邻或共享组件依赖的路径

### 5.3 单测规划（改动前先定范围）

**检查点**
- 哪些逻辑可以用 JVM 单测覆盖（纯逻辑/数据转换/解析）
- 哪些必须依赖 Android 环境（再考虑仪器测试或拆分可测试逻辑）
- 覆盖分支：成功/失败/异常/边界值

**失败回滚策略**
- 若无法制定可执行验证：先把改动拆小到“可验证的最小单元”，再进入实现。

---

## Step 6：回滚预案（先写“出问题怎么办”）

**目标**：保证出现问题时能快速止损，且不会导致数据不可逆损坏。

**检查点**
- 触发条件：什么信号出现就必须回滚（崩溃、ANR、关键功能不可用等）
- 回滚方式：
  - 回退提交
  - 保留旧逻辑的降级分支（如有）
  - 关闭开关（如项目支持配置/实验开关）
- 数据处理：
  - 是否落盘/迁移
  - 是否可逆
  - 回滚后旧数据如何兼容

**失败回滚策略**
- 若存在不可逆数据迁移：必须设计双写/兼容读取/版本标记；否则禁止推进实现。

---

## Step 7：任务拆分（让实现可控、可回退、可验证）

**目标**：把一次大改拆成多个可独立验收的最小改动单元。

**检查点**
- 是否能拆为：观测/重构铺垫/核心改动/测试/收尾清理
- 每个子任务是否都有清晰的验证点与回滚方式
- 是否避免把“格式化大改”混入功能提交

**失败回滚策略**
- 若无法拆分：明确原因与风险，并把验证计划加倍（更多回归路径与单测覆盖）。